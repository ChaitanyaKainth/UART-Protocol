module uart_tx #(
    parameter CLK_FREQ = 50_000_000,   // 50 MHz system clock
    parameter BAUD     = 9600
)(
    input  logic       clk,
    input  logic       rst_n,
    input  logic       tx_start,       // pulse to start transmission
    input  logic [7:0] tx_data,
    output logic       tx,
    output logic       tx_busy,
    output logic       tx_done
);

    // ---------------------------------------
    // Baud rate generator
    // ---------------------------------------
    localparam int BAUD_DIV = CLK_FREQ / BAUD;

    logic [$clog2(BAUD_DIV)-1:0] baud_cnt;
    logic baud_tick;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            baud_cnt  <= 0;
            baud_tick <= 0;
        end
        else if (baud_cnt == BAUD_DIV-1) begin
            baud_cnt  <= 0;
            baud_tick <= 1;
        end
        else begin
            baud_cnt  <= baud_cnt + 1;
            baud_tick <= 0;
        end
    end

    // ---------------------------------------
    // TX State Machine
    // ---------------------------------------
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state;
    logic [2:0] bit_index;
    logic [7:0] data_reg;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state     <= IDLE;
            tx        <= 1'b1;   // idle high
            tx_busy   <= 0;
            tx_done   <= 0;
            bit_index <= 0;
            data_reg  <= 0;
        end
        else begin
            tx_done <= 0;

            if (baud_tick) begin
                case (state)

                    IDLE: begin
                        tx <= 1'b1;
                        tx_busy <= 0;

                        if (tx_start) begin
                            data_reg  <= tx_data;
                            state     <= START;
                            tx_busy   <= 1;
                        end
                    end

                    START: begin
                        tx <= 1'b0;  // start bit
                        state <= DATA;
                        bit_index <= 0;
                    end

                    DATA: begin
                        tx <= data_reg[bit_index];
                        if (bit_index == 3'd7)
                            state <= STOP;
                        else
                            bit_index <= bit_index + 1;
                    end

                    STOP: begin
                        tx <= 1'b1;  // stop bit
                        state <= IDLE;
                        tx_done <= 1;
                    end

                endcase
            end
        end
    end

endmodule